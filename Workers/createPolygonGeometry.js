/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.110
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
import{a as Pt}from"./chunk-YF5DBGG5.js";import{a as S}from"./chunk-JZTQKYX2.js";import{a as X}from"./chunk-GDU4HM25.js";import{a as ft}from"./chunk-XCRGRNQS.js";import{a as It}from"./chunk-SWN2FXZS.js";import"./chunk-7QQVIQUI.js";import"./chunk-KHY6RFC7.js";import{a as At}from"./chunk-N23XWOUQ.js";import{a as Tt}from"./chunk-FPRO6JNE.js";import{a as dt}from"./chunk-RC3J75N5.js";import{a as Q}from"./chunk-H77XG57N.js";import{a as J}from"./chunk-B5XY4KJS.js";import"./chunk-BXEYVAPQ.js";import{a as _t,b as at}from"./chunk-OG7KJPIH.js";import"./chunk-HD5MEFMW.js";import"./chunk-JNTN7NAL.js";import{a as bt,b as Et}from"./chunk-AAT5S4I6.js";import"./chunk-S2GBLW2R.js";import{a as ut}from"./chunk-7P3UWTUX.js";import"./chunk-GIF3NIGD.js";import{c as pt,d as ot}from"./chunk-7VHC7I6W.js";import{d as Ot,f as mt}from"./chunk-VNH2ZAFU.js";import"./chunk-2YKWURU2.js";import{c as lt,d as b}from"./chunk-TL76KVMB.js";import{a as et}from"./chunk-EK7K4JTS.js";import{a as h,b as K,c as v,d as U}from"./chunk-TZVAMLG3.js";import{a as c}from"./chunk-7IOYEWZQ.js";import"./chunk-XE4KLUZ2.js";import"./chunk-TL6AL3PA.js";import{a as H}from"./chunk-DYKDQ7Q5.js";import{a as rt,b as G}from"./chunk-57R6MEVR.js";import{e as P}from"./chunk-KNXNZS2Q.js";function Dt(t,e){if(!P(t)||!P(e))throw new rt("identifier and message are required.");At(t,e)}var Nt=Dt;function O(t,e){this.position=t,P(this.position)||(this.position=new b),this.tangentPlane=e,P(this.tangentPlane)||(this.tangentPlane=O.NORTH_POLE_TANGENT_PLANE)}Object.defineProperties(O.prototype,{ellipsoid:{get:function(){return this.tangentPlane.ellipsoid}},x:{get:function(){return this.position.x}},y:{get:function(){return this.position.y}},conformalLatitude:{get:function(){let t=b.magnitude(this.position),e=2*this.ellipsoid.maximumRadius;return this.tangentPlane.plane.normal.z*(c.PI_OVER_TWO-2*Math.atan2(t,e))}},longitude:{get:function(){let t=c.PI_OVER_TWO+Math.atan2(this.y,this.x);return t>Math.PI&&(t-=c.TWO_PI),t}}});var st=new K,Vt=new h;O.prototype.getLatitude=function(t){P(t)||(t=v.WGS84),st.latitude=this.conformalLatitude,st.longitude=this.longitude,st.height=0;let e=this.ellipsoid.cartographicToCartesian(st,Vt);return t.cartesianToCartographic(e,st),st.latitude};var Mt=new bt,Bt=new h,jt=new h;O.fromCartesian=function(t,e){G.defined("cartesian",t);let o=c.signNotZero(t.z),n=O.NORTH_POLE_TANGENT_PLANE,r=O.SOUTH_POLE;o<0&&(n=O.SOUTH_POLE_TANGENT_PLANE,r=O.NORTH_POLE);let i=Mt;i.origin=n.ellipsoid.scaleToGeocentricSurface(t,i.origin),i.direction=h.subtract(i.origin,r,Bt),h.normalize(i.direction,i.direction);let a=Et.rayPlane(i,n.plane,jt),s=h.subtract(a,r,a),l=h.dot(n.xAxis,s),u=o*h.dot(n.yAxis,s);return P(e)?(e.position=new b(l,u),e.tangentPlane=n,e):new O(new b(l,u),n)},O.fromCartesianArray=function(t,e){G.defined("cartesians",t);let o=t.length;P(e)?e.length=o:e=new Array(o);for(let n=0;n<o;n++)e[n]=O.fromCartesian(t[n],e[n]);return e},O.clone=function(t,e){if(P(t))return P(e)?(e.position=t.position,e.tangentPlane=t.tangentPlane,e):new O(t.position,t.tangentPlane)},O.HALF_UNIT_SPHERE=Object.freeze(new v(.5,.5,.5)),O.NORTH_POLE=Object.freeze(new h(0,0,.5)),O.SOUTH_POLE=Object.freeze(new h(0,0,-.5)),O.NORTH_POLE_TANGENT_PLANE=Object.freeze(new J(O.NORTH_POLE,O.HALF_UNIT_SPHERE)),O.SOUTH_POLE_TANGENT_PLANE=Object.freeze(new J(O.SOUTH_POLE,O.HALF_UNIT_SPHERE));var k=O,Wt=new K,Ht=new K;function Gt(t,e,o,n){let r=n.cartesianToCartographic(t,Wt).height,i=n.cartesianToCartographic(e,Ht);i.height=r,n.cartographicToCartesian(i,e);let a=n.cartesianToCartographic(o,Ht);a.height=r-100,n.cartographicToCartesian(a,o)}var Ct=new Pt,kt=new h,zt=new h,Ut=new h,Yt=new h,qt=new h,Qt=new h,gt=new h,Z=new h,ct=new h,Jt=new b,Zt=new b,Kt=new h,xt=new mt,Xt=new U,$t=new U;function wt(t){let e=t.vertexFormat,o=t.geometry,n=t.shadowVolume,r=o.attributes.position.values,i=P(o.attributes.st)?o.attributes.st.values:void 0,a=r.length,s=t.wall,l=t.top||s,u=t.bottom||s;if(e.st||e.normal||e.tangent||e.bitangent||n){let p=t.boundingRectangle,g=t.rotationAxis,m=t.projectTo2d,d=t.ellipsoid,f=t.stRotation,y=t.perPositionHeight,_=Jt;_.x=p.x,_.y=p.y;let I,O=e.st?new Float32Array(a/3*2):void 0;e.normal&&(I=y&&l&&!s?o.attributes.normal.values:new Float32Array(a));let T=e.tangent?new Float32Array(a):void 0,w=e.bitangent?new Float32Array(a):void 0,v=n?new Float32Array(a):void 0,E=0,H=0,N=zt,A=Ut,x=Yt,R=!0,S=Xt,L=$t;if(0!==f){let t=mt.fromAxisAngle(g,f,xt);S=U.fromQuaternion(t,S),t=mt.fromAxisAngle(g,-f,xt),L=U.fromQuaternion(t,L)}else S=U.clone(U.IDENTITY,S),L=U.clone(U.IDENTITY,L);let k=0,G=0;l&&u&&(k=a/2,G=a/3,a/=2);for(let o=0;o<a;o+=3){let g=h.fromArray(r,o,Kt);if(e.st&&!P(i)){let t=U.multiplyByVector(S,g,kt);t=d.scaleToGeodeticSurface(t,t);let e=m(t,Zt);b.subtract(e,_,e);let o=c.clamp(e.x/p.width,0,1),n=c.clamp(e.y/p.height,0,1);u&&(O[E+G]=o,O[E+1+G]=n),l&&(O[E]=o,O[E+1]=n),E+=2}if(e.normal||e.tangent||e.bitangent||n){let i=H+1,p=H+2;if(s){if(o+3<a){let t=h.fromArray(r,o+3,qt);if(R){let e=h.fromArray(r,o+a,Qt);y&&Gt(g,t,e,d),h.subtract(t,g,t),h.subtract(e,g,e),N=h.normalize(h.cross(e,t,N),N),R=!1}h.equalsEpsilon(t,g,c.EPSILON10)&&(R=!0)}(e.tangent||e.bitangent)&&(x=d.geodeticSurfaceNormal(g,x),e.tangent&&(A=h.normalize(h.cross(x,N,A),A)))}else N=d.geodeticSurfaceNormal(g,N),(e.tangent||e.bitangent)&&(y&&(gt=h.fromArray(I,H,gt),Z=h.cross(h.UNIT_Z,gt,Z),Z=h.normalize(U.multiplyByVector(L,Z,Z),Z),e.bitangent&&(ct=h.normalize(h.cross(gt,Z,ct),ct))),A=h.cross(h.UNIT_Z,N,A),A=h.normalize(U.multiplyByVector(L,A,A),A),e.bitangent&&(x=h.normalize(h.cross(N,A,x),x)));e.normal&&(t.wall?(I[H+k]=N.x,I[i+k]=N.y,I[p+k]=N.z):u&&(I[H+k]=-N.x,I[i+k]=-N.y,I[p+k]=-N.z),(l&&!y||s)&&(I[H]=N.x,I[i]=N.y,I[p]=N.z)),n&&(s&&(N=d.geodeticSurfaceNormal(g,N)),v[H+k]=-N.x,v[i+k]=-N.y,v[p+k]=-N.z),e.tangent&&(t.wall?(T[H+k]=A.x,T[i+k]=A.y,T[p+k]=A.z):u&&(T[H+k]=-A.x,T[i+k]=-A.y,T[p+k]=-A.z),l&&(y?(T[H]=Z.x,T[i]=Z.y,T[p]=Z.z):(T[H]=A.x,T[i]=A.y,T[p]=A.z))),e.bitangent&&(u&&(w[H+k]=x.x,w[i+k]=x.y,w[p+k]=x.z),l&&(y?(w[H]=ct.x,w[i]=ct.y,w[p]=ct.z):(w[H]=x.x,w[i]=x.y,w[p]=x.z))),H+=3}}e.st&&!P(i)&&(o.attributes.st=new ot({componentDatatype:et.FLOAT,componentsPerAttribute:2,values:O})),e.normal&&(o.attributes.normal=new ot({componentDatatype:et.FLOAT,componentsPerAttribute:3,values:I})),e.tangent&&(o.attributes.tangent=new ot({componentDatatype:et.FLOAT,componentsPerAttribute:3,values:T})),e.bitangent&&(o.attributes.bitangent=new ot({componentDatatype:et.FLOAT,componentsPerAttribute:3,values:w})),n&&(o.attributes.extrudeDirection=new ot({componentDatatype:et.FLOAT,componentsPerAttribute:3,values:v}))}if(t.extrude&&P(t.offsetAttribute)){let e=r.length/3,n=new Uint8Array(e);if(t.offsetAttribute===dt.TOP)l&&u||s?n=n.fill(1,0,e/2):l&&(n=n.fill(1));else{let e=t.offsetAttribute===dt.NONE?0:1;n=n.fill(e)}o.attributes.applyOffset=new ot({componentDatatype:et.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return o}var te=new K,ee=new K,nt={westOverIDL:0,eastOverIDL:0},ht=new Tt;function oe(t,e,o,n,r){if(r=H(r,new lt),!P(t)||t.length<3)return r.west=0,r.north=0,r.south=0,r.east=0,r;if(o===X.RHUMB)return lt.fromCartesianArray(t,e,r);ht.ellipsoid.equals(e)||(ht=new Tt(void 0,void 0,e)),r.west=Number.POSITIVE_INFINITY,r.east=Number.NEGATIVE_INFINITY,r.south=Number.POSITIVE_INFINITY,r.north=Number.NEGATIVE_INFINITY,nt.westOverIDL=Number.POSITIVE_INFINITY,nt.eastOverIDL=Number.NEGATIVE_INFINITY;let i,a=1/c.chordLength(n,e.maximumRadius),s=t.length,l=e.cartesianToCartographic(t[0],ee),h=te;for(let c=1;c<s;c++)i=h,h=l,l=e.cartesianToCartographic(t[c],i),ht.setEndPoints(h,l),Rt(ht,a,r,nt);return i=h,h=l,l=e.cartesianToCartographic(t[0],i),ht.setEndPoints(h,l),Rt(ht,a,r,nt),r.east-r.west>nt.eastOverIDL-nt.westOverIDL&&(r.west=nt.westOverIDL,r.east=nt.eastOverIDL,r.east>c.PI&&(r.east=r.east-c.TWO_PI),r.west>c.PI&&(r.west=r.west-c.TWO_PI)),r}var ne=new K;function Rt(t,e,o,n){let r=t.surfaceDistance,i=Math.ceil(r*e),a=i>0?r/(i-1):Number.POSITIVE_INFINITY,s=0;for(let l=0;l<i;l++){let e=t.interpolateUsingSurfaceDistance(s,ne);s+=a;let r=e.longitude,i=e.latitude;o.west=Math.min(o.west,r),o.east=Math.max(o.east,r),o.south=Math.min(o.south,i),o.north=Math.max(o.north,i);let l=r>=0?r:r+c.TWO_PI;n.westOverIDL=Math.min(n.westOverIDL,l),n.eastOverIDL=Math.max(n.eastOverIDL,l)}}var Lt=[];function ie(t,e,o,n,r,i,a,s,l,c){let h,u={walls:[]};if(a||s){let r,p,g=S.createGeometryFromPositions(t,e,o,n,i,l,c),m=g.attributes.position.values,d=g.indices;if(a&&s){let t=m.concat(m);r=t.length/3,p=ut.createTypedArray(r,2*d.length),p.set(d);let e=d.length,n=r/2;for(h=0;h<e;h+=3){let t=p[h]+n,o=p[h+1]+n,r=p[h+2]+n;p[h+e]=r,p[h+1+e]=o,p[h+2+e]=t}if(g.attributes.position.values=t,i&&l.normal){let e=g.attributes.normal.values;g.attributes.normal.values=new Float32Array(t.length),g.attributes.normal.values.set(e)}if(l.st&&P(o)){let t=g.attributes.st.values;g.attributes.st.values=new Float32Array(2*r),g.attributes.st.values=t.concat(t)}g.indices=p}else if(s){for(r=m.length/3,p=ut.createTypedArray(r,d.length),h=0;h<d.length;h+=3)p[h]=d[h+2],p[h+1]=d[h+1],p[h+2]=d[h];g.indices=p}u.topAndBottom=new ft({geometry:g})}let p=r.outerRing,g=J.fromPoints(p,t),m=g.projectPointsOntoPlane(p,Lt),d=at.computeWindingOrder2D(m);d===_t.CLOCKWISE&&(p=p.slice().reverse());let f=S.computeWallGeometry(p,o,t,n,i,c);u.walls.push(new ft({geometry:f}));let y=r.holes;for(h=0;h<y.length;h++){let e=y[h];g=J.fromPoints(e,t),m=g.projectPointsOntoPlane(e,Lt),d=at.computeWindingOrder2D(m),d===_t.COUNTER_CLOCKWISE&&(e=e.slice().reverse()),f=S.computeWallGeometry(e,o,t,n,i,c),u.walls.push(new ft({geometry:f}))}return u}function z(t){if(G.typeOf.object("options",t),G.typeOf.object("options.polygonHierarchy",t.polygonHierarchy),P(t.perPositionHeight)&&t.perPositionHeight&&P(t.height))throw new rt("Cannot use both options.perPositionHeight and options.height");if(P(t.arcType)&&t.arcType!==X.GEODESIC&&t.arcType!==X.RHUMB)throw new rt("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");let e=t.polygonHierarchy,o=H(t.vertexFormat,Q.DEFAULT),n=H(t.ellipsoid,v.WGS84),r=H(t.granularity,c.RADIANS_PER_DEGREE),i=H(t.stRotation,0),a=t.textureCoordinates,s=H(t.perPositionHeight,!1),l=s&&P(t.extrudedHeight),u=H(t.height,0),p=H(t.extrudedHeight,u);if(!l){let t=Math.max(u,p);p=Math.min(u,p),u=t}this._vertexFormat=Q.clone(o),this._ellipsoid=v.clone(n),this._granularity=r,this._stRotation=i,this._height=u,this._extrudedHeight=p,this._closeTop=H(t.closeTop,!0),this._closeBottom=H(t.closeBottom,!0),this._polygonHierarchy=e,this._perPositionHeight=s,this._perPositionHeightExtrude=l,this._shadowVolume=H(t.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=t.offsetAttribute,this._arcType=H(t.arcType,X.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=a,this.packedLength=S.computeHierarchyPackedLength(e,h)+v.packedLength+Q.packedLength+(a?S.computeHierarchyPackedLength(a,b):1)+12}z.fromPositions=function(t){t=H(t,H.EMPTY_OBJECT),G.defined("options.positions",t.positions);let e={polygonHierarchy:{positions:t.positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType,textureCoordinates:t.textureCoordinates};return new z(e)},z.pack=function(t,e,o){return G.typeOf.object("value",t),G.defined("array",e),o=H(o,0),o=S.packPolygonHierarchy(t._polygonHierarchy,e,o,h),v.pack(t._ellipsoid,e,o),o+=v.packedLength,Q.pack(t._vertexFormat,e,o),o+=Q.packedLength,e[o++]=t._height,e[o++]=t._extrudedHeight,e[o++]=t._granularity,e[o++]=t._stRotation,e[o++]=t._perPositionHeightExtrude?1:0,e[o++]=t._perPositionHeight?1:0,e[o++]=t._closeTop?1:0,e[o++]=t._closeBottom?1:0,e[o++]=t._shadowVolume?1:0,e[o++]=H(t._offsetAttribute,-1),e[o++]=t._arcType,P(t._textureCoordinates)?o=S.packPolygonHierarchy(t._textureCoordinates,e,o,b):e[o++]=-1,e[o++]=t.packedLength,e};var re=v.clone(v.UNIT_SPHERE),ae=new Q,se={polygonHierarchy:{}};z.unpack=function(t,e,o){G.defined("array",t),e=H(e,0);let n=S.unpackPolygonHierarchy(t,e,h);e=n.startingIndex,delete n.startingIndex;let r=v.unpack(t,e,re);e+=v.packedLength;let i=Q.unpack(t,e,ae);e+=Q.packedLength;let a=t[e++],s=t[e++],l=t[e++],c=t[e++],u=1===t[e++],p=1===t[e++],g=1===t[e++],m=1===t[e++],d=1===t[e++],f=t[e++],y=t[e++],_=-1===t[e]?void 0:S.unpackPolygonHierarchy(t,e,b);P(_)?(e=_.startingIndex,delete _.startingIndex):e++;let I=t[e++];return P(o)||(o=new z(se)),o._polygonHierarchy=n,o._ellipsoid=v.clone(r,o._ellipsoid),o._vertexFormat=Q.clone(i,o._vertexFormat),o._height=a,o._extrudedHeight=s,o._granularity=l,o._stRotation=c,o._perPositionHeightExtrude=u,o._perPositionHeight=p,o._closeTop=g,o._closeBottom=m,o._shadowVolume=d,o._offsetAttribute=-1===f?void 0:f,o._arcType=y,o._textureCoordinates=_,o.packedLength=I,o};var ce=new b,he=new b,fe=new k;function vt(t,e,o,n,r,i){let a=t.longitude,s=a>=0?a:a+c.TWO_PI;r.westOverIdl=Math.min(r.westOverIdl,s),r.eastOverIdl=Math.max(r.eastOverIdl,s),i.west=Math.min(i.west,a),i.east=Math.max(i.east,a);let l=t.getLatitude(o),h=l;if(i.south=Math.min(i.south,l),i.north=Math.max(i.north,l),n!==X.RHUMB){let n=b.subtract(e.position,t.position,ce),r=b.dot(e.position,n)/b.dot(n,n);if(r>0&&r<1){let t=b.add(e.position,b.multiplyByScalar(n,-r,n),he),a=k.clone(e,fe);a.position=t;let s=a.getLatitude(o);i.south=Math.min(i.south,s),i.north=Math.max(i.north,s),Math.abs(l)>Math.abs(s)&&(h=s)}}let u=e.x*t.y-t.x*e.y,p=Math.sign(u);0!==p&&(p*=b.angleBetween(e.position,t.position)),h>=0&&(r.northAngle+=p),h<=0&&(r.southAngle+=p)}var St=new k,le=new k,Y={northAngle:0,southAngle:0,westOverIdl:0,eastOverIdl:0};z.computeRectangleFromPositions=function(t,e,o,n){if(G.defined("positions",t),P(n)||(n=new lt),t.length<3)return n;n.west=Number.POSITIVE_INFINITY,n.east=Number.NEGATIVE_INFINITY,n.south=Number.POSITIVE_INFINITY,n.north=Number.NEGATIVE_INFINITY,Y.northAngle=0,Y.southAngle=0,Y.westOverIdl=Number.POSITIVE_INFINITY,Y.eastOverIdl=Number.NEGATIVE_INFINITY;let r=t.length,i=k.fromCartesian(t[0],le);for(let a=1;a<r;a++){let r=k.fromCartesian(t[a],St);vt(r,i,e,o,Y,n),i=k.clone(r,i)}return vt(k.fromCartesian(t[0],St),i,e,o,Y,n),n.east-n.west>Y.eastOverIdl-Y.westOverIdl&&(n.west=Y.westOverIdl,n.east=Y.eastOverIdl,n.east>c.PI&&(n.east=n.east-c.TWO_PI),n.west>c.PI&&(n.west=n.west-c.TWO_PI)),c.equalsEpsilon(Math.abs(Y.northAngle),c.TWO_PI,c.EPSILON10)&&(n.north=c.PI_OVER_TWO,n.east=c.PI,n.west=-c.PI),c.equalsEpsilon(Math.abs(Y.southAngle),c.TWO_PI,c.EPSILON10)&&(n.south=-c.PI_OVER_TWO,n.east=c.PI,n.west=-c.PI),n},z.computeRectangle=function(t,e){G.typeOf.object("options",t),G.typeOf.object("options.polygonHierarchy",t.polygonHierarchy),Nt("PolygonGeometry.computeRectangle","PolygonGeometry.computeRectangle was deprecated in CesiumJS 1.110.  It will be removed in CesiumJS 1.112. Use PolygonGeometry.computeRectangleFromPositions instead.");let o=H(t.granularity,c.RADIANS_PER_DEGREE),n=H(t.arcType,X.GEODESIC);if(n!==X.GEODESIC&&n!==X.RHUMB)throw new rt("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");let r=t.polygonHierarchy,i=H(t.ellipsoid,v.WGS84);return oe(r.positions,i,n,o,e)};var me=new k;function ue(t,e,o){return t.height>=c.PI||t.width>=c.PI?k.fromCartesian(e[0],me).tangentPlane:J.fromPoints(e,o)}var Ft=new K;function de(t,e){return(o,n)=>{if(t.height>=c.PI||t.width>=c.PI){if(t.south<0&&t.north>0){P(n)||(n=[]);for(let t=0;t<o.length;++t){let r=e.cartesianToCartographic(o[t],Ft);n[t]=new b(r.longitude/c.PI,r.latitude/c.PI_OVER_TWO)}return n.length=o.length,n}return k.fromCartesianArray(o,n)}return J.fromPoints(o,e).projectPointsOntoPlane(o,n)}}function ge(t,e,o){if(t.height>=c.PI||t.width>=c.PI)return(e,n)=>{if(t.south<0&&t.north>0){let t=o.cartesianToCartographic(e,Ft);return P(n)||(n=new b),n.x=t.longitude/c.PI,n.y=t.latitude/c.PI_OVER_TWO,n}return k.fromCartesian(e,n)};let n=J.fromPoints(e,o);return(t,e)=>n.projectPointsOntoPlane(t,e)}function pe(t,e,o,n){return(r,i)=>!n&&(t.height>=c.PI_OVER_TWO||t.width>=2*c.PI_OVER_THREE)?S.splitPolygonsOnEquator(r,e,o,i):r}function Pe(t,e,o,n){if(e.height>=c.PI||e.width>=c.PI)return Pt.fromRectangle(e,void 0,Ct);let r=t,i=J.fromPoints(r,o);return S.computeBoundingRectangle(i.plane.normal,i.projectPointOntoPlane.bind(i),r,n,Ct)}function _e(t){let e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];let o=t._ellipsoid,n=t._polygonHierarchy.positions,r=t.rectangle;return pt._textureCoordinateRotationPoints(n,e,o,r)}z.createGeometry=function(t){let e=t._vertexFormat,o=t._ellipsoid,n=t._granularity,r=t._stRotation,i=t._polygonHierarchy,a=t._perPositionHeight,s=t._closeTop,l=t._closeBottom,h=t._arcType,u=t._textureCoordinates,p=P(u);if(i.positions.length<3)return;let g=t.rectangle,m=S.polygonsFromHierarchy(i,p,de(g,o),!a,o,pe(g,o,h,a)),d=m.hierarchy,f=m.polygons,y=function(t){return t},_=p?S.polygonsFromHierarchy(u,!0,y,!1,o).polygons:void 0;if(0===d.length)return;let I,O=d[0].outerRing,T=Pe(O,g,o,r),w=[],b=t._height,v=t._extrudedHeight,E=t._perPositionHeightExtrude||!c.equalsEpsilon(b,v,0,c.EPSILON2),H={perPositionHeight:a,vertexFormat:e,geometry:void 0,rotationAxis:ue(g,O,o).plane.normal,projectTo2d:ge(g,O,o),boundingRectangle:T,ellipsoid:o,stRotation:r,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:h};if(E)for(H.extrude=!0,H.top=s,H.bottom=l,H.shadowVolume=t._shadowVolume,H.offsetAttribute=t._offsetAttribute,I=0;I<f.length;I++){let t,r=ie(o,f[I],p?_[I]:void 0,n,d[I],a,s,l,e,h);s&&l?(t=r.topAndBottom,H.geometry=S.scaleToGeodeticHeightExtruded(t.geometry,b,v,o,a)):s?(t=r.topAndBottom,t.geometry.attributes.position.values=at.scaleToGeodeticHeight(t.geometry.attributes.position.values,b,o,!a),H.geometry=t.geometry):l&&(t=r.topAndBottom,t.geometry.attributes.position.values=at.scaleToGeodeticHeight(t.geometry.attributes.position.values,v,o,!0),H.geometry=t.geometry),(s||l)&&(H.wall=!1,t.geometry=wt(H),w.push(t));let i=r.walls;H.wall=!0;for(let e=0;e<i.length;e++){let t=i[e];H.geometry=S.scaleToGeodeticHeightExtruded(t.geometry,b,v,o,a),t.geometry=wt(H),w.push(t)}}else for(I=0;I<f.length;I++){let r=new ft({geometry:S.createGeometryFromPositions(o,f[I],p?_[I]:void 0,n,a,e,h)});if(r.geometry.attributes.position.values=at.scaleToGeodeticHeight(r.geometry.attributes.position.values,b,o,!a),H.geometry=r.geometry,r.geometry=wt(H),P(t._offsetAttribute)){let e=r.geometry.attributes.position.values.length,o=t._offsetAttribute===dt.NONE?0:1,n=new Uint8Array(e/3).fill(o);r.geometry.attributes.applyOffset=new ot({componentDatatype:et.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}w.push(r)}let N=It.combineInstances(w)[0];N.attributes.position.values=new Float64Array(N.attributes.position.values),N.indices=ut.createTypedArray(N.attributes.position.values.length/3,N.indices);let A=N.attributes,x=Ot.fromVertices(A.position.values);return e.position||delete A.position,new pt({attributes:A,indices:N.indices,primitiveType:N.primitiveType,boundingSphere:x,offsetAttribute:t._offsetAttribute})},z.createShadowVolume=function(t,e,o){let n=t._granularity,r=t._ellipsoid,i=e(n,r),a=o(n,r);return new z({polygonHierarchy:t._polygonHierarchy,ellipsoid:r,stRotation:t._stRotation,granularity:n,perPositionHeight:!1,extrudedHeight:i,height:a,vertexFormat:Q.POSITION_ONLY,shadowVolume:!0,arcType:t._arcType})},Object.defineProperties(z.prototype,{rectangle:{get:function(){if(!P(this._rectangle)){let t=this._polygonHierarchy.positions;this._rectangle=z.computeRectangleFromPositions(t,this._ellipsoid,this._arcType)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return P(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=_e(this)),this._textureCoordinateRotationPoints}}});var yt=z;function Te(t,e){return P(e)&&(t=yt.unpack(t,e)),t._ellipsoid=v.clone(t._ellipsoid),yt.createGeometry(t)}var po=Te;export{po as default};