/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.110
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
import{a as nt}from"./chunk-5HIWY7S3.js";import"./chunk-3WBGP35M.js";import"./chunk-FPRO6JNE.js";import{a as _}from"./chunk-H77XG57N.js";import"./chunk-HD5MEFMW.js";import"./chunk-JNTN7NAL.js";import"./chunk-AAT5S4I6.js";import"./chunk-S2GBLW2R.js";import{a as ot}from"./chunk-7P3UWTUX.js";import{a as it}from"./chunk-GIF3NIGD.js";import{b as tt,c as et,d as R}from"./chunk-7VHC7I6W.js";import{d as I}from"./chunk-VNH2ZAFU.js";import"./chunk-2YKWURU2.js";import"./chunk-TL76KVMB.js";import{a as S}from"./chunk-EK7K4JTS.js";import{a as s,c as l}from"./chunk-TZVAMLG3.js";import{a as J}from"./chunk-7IOYEWZQ.js";import"./chunk-XE4KLUZ2.js";import"./chunk-TL6AL3PA.js";import{a as w}from"./chunk-DYKDQ7Q5.js";import{a as P}from"./chunk-57R6MEVR.js";import{e as r}from"./chunk-KNXNZS2Q.js";var Q=new s,Y=new s,lt=new s,st=new s,pt=new s,ut=new s,ft=new s;function k(t){t=w(t,w.EMPTY_OBJECT);let e=t.positions,i=t.maximumHeights,n=t.minimumHeights;if(!r(e))throw new P("options.positions is required.");if(r(i)&&i.length!==e.length)throw new P("options.positions and options.maximumHeights must have the same length.");if(r(n)&&n.length!==e.length)throw new P("options.positions and options.minimumHeights must have the same length.");let o=w(t.vertexFormat,_.DEFAULT),a=w(t.granularity,J.RADIANS_PER_DEGREE),m=w(t.ellipsoid,l.WGS84);this._positions=e,this._minimumHeights=n,this._maximumHeights=i,this._vertexFormat=_.clone(o),this._granularity=a,this._ellipsoid=l.clone(m),this._workerName="createWallGeometry";let p=1+e.length*s.packedLength+2;r(n)&&(p+=n.length),r(i)&&(p+=i.length),this.packedLength=p+l.packedLength+_.packedLength+1}k.pack=function(t,e,i){if(!r(t))throw new P("value is required");if(!r(e))throw new P("array is required");i=w(i,0);let n,o=t._positions,a=o.length;for(e[i++]=a,n=0;n<a;++n,i+=s.packedLength)s.pack(o[n],e,i);let m=t._minimumHeights;if(a=r(m)?m.length:0,e[i++]=a,r(m))for(n=0;n<a;++n)e[i++]=m[n];let p=t._maximumHeights;if(a=r(p)?p.length:0,e[i++]=a,r(p))for(n=0;n<a;++n)e[i++]=p[n];return l.pack(t._ellipsoid,e,i),i+=l.packedLength,_.pack(t._vertexFormat,e,i),i+=_.packedLength,e[i]=t._granularity,e};var mt=l.clone(l.UNIT_SPHERE),rt=new _,M={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:mt,vertexFormat:rt,granularity:void 0};k.unpack=function(t,e,i){if(!r(t))throw new P("array is required");e=w(e,0);let n,o,a,m=t[e++],p=new Array(m);for(n=0;n<m;++n,e+=s.packedLength)p[n]=s.unpack(t,e);if(m=t[e++],m>0)for(o=new Array(m),n=0;n<m;++n)o[n]=t[e++];if(m=t[e++],m>0)for(a=new Array(m),n=0;n<m;++n)a[n]=t[e++];let u=l.unpack(t,e,mt);e+=l.packedLength;let h=_.unpack(t,e,rt);e+=_.packedLength;let c=t[e];return r(i)?(i._positions=p,i._minimumHeights=o,i._maximumHeights=a,i._ellipsoid=l.clone(u,i._ellipsoid),i._vertexFormat=_.clone(h,i._vertexFormat),i._granularity=c,i):(M.positions=p,M.minimumHeights=o,M.maximumHeights=a,M.granularity=c,new k(M))},k.fromConstantHeights=function(t){t=w(t,w.EMPTY_OBJECT);let e=t.positions;if(!r(e))throw new P("options.positions is required.");let i,n,o=t.minimumHeight,s=t.maximumHeight,a=r(o),m=r(s);if(a||m){let t=e.length;i=a?new Array(t):void 0,n=m?new Array(t):void 0;for(let e=0;e<t;++e)a&&(i[e]=o),m&&(n[e]=s)}let l={positions:e,maximumHeights:n,minimumHeights:i,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat};return new k(l)},k.createGeometry=function(t){let e=t._positions,i=t._minimumHeights,n=t._maximumHeights,o=t._vertexFormat,a=t._granularity,m=t._ellipsoid,l=nt.computePositions(m,e,n,i,a,!0);if(!r(l))return;let p=l.bottomPositions,u=l.topPositions,h=l.numCorners,c=u.length,g=2*c,f=o.position?new Float64Array(g):void 0,w=o.normal?new Float32Array(g):void 0,k=o.tangent?new Float32Array(g):void 0,d=o.bitangent?new Float32Array(g):void 0,_=o.st?new Float32Array(g/3*2):void 0,y=0,A=0,v=0,x=0,H=0,L=ft,P=ut,E=pt,F=!0;c/=3;let j,T=0,b=1/(c-h-1);for(j=0;j<c;++j){let t=3*j,e=s.fromArray(u,t,Q),i=s.fromArray(p,t,Y);if(o.position&&(f[y++]=i.x,f[y++]=i.y,f[y++]=i.z,f[y++]=e.x,f[y++]=e.y,f[y++]=e.z),o.st&&(_[H++]=T,_[H++]=0,_[H++]=T,_[H++]=1),o.normal||o.tangent||o.bitangent){let i=s.clone(s.ZERO,st),n=s.subtract(e,m.geodeticSurfaceNormal(e,Y),Y);if(j+1<c&&(i=s.fromArray(u,t+3,st)),F){let t=s.subtract(i,e,lt),r=s.subtract(n,e,Q);L=s.normalize(s.cross(r,t,L),L),F=!1}s.equalsEpsilon(e,i,J.EPSILON10)?F=!0:(T+=b,o.tangent&&(P=s.normalize(s.subtract(i,e,P),P)),o.bitangent&&(E=s.normalize(s.cross(L,P,E),E))),o.normal&&(w[A++]=L.x,w[A++]=L.y,w[A++]=L.z,w[A++]=L.x,w[A++]=L.y,w[A++]=L.z),o.tangent&&(k[x++]=P.x,k[x++]=P.y,k[x++]=P.z,k[x++]=P.x,k[x++]=P.y,k[x++]=P.z),o.bitangent&&(d[v++]=E.x,d[v++]=E.y,d[v++]=E.z,d[v++]=E.x,d[v++]=E.y,d[v++]=E.z)}}let N=new it;o.position&&(N.position=new R({componentDatatype:S.DOUBLE,componentsPerAttribute:3,values:f})),o.normal&&(N.normal=new R({componentDatatype:S.FLOAT,componentsPerAttribute:3,values:w})),o.tangent&&(N.tangent=new R({componentDatatype:S.FLOAT,componentsPerAttribute:3,values:k})),o.bitangent&&(N.bitangent=new R({componentDatatype:S.FLOAT,componentsPerAttribute:3,values:d})),o.st&&(N.st=new R({componentDatatype:S.FLOAT,componentsPerAttribute:2,values:_}));let M=g/3;g-=6*(h+1);let O=ot.createTypedArray(M,g),D=0;for(j=0;j<M-2;j+=2){let t=j,e=j+2,i=s.fromArray(f,3*t,Q),n=s.fromArray(f,3*e,Y);if(s.equalsEpsilon(i,n,J.EPSILON10))continue;let r=j+1,o=j+3;O[D++]=r,O[D++]=t,O[D++]=o,O[D++]=o,O[D++]=t,O[D++]=e}return new et({attributes:N,indices:O,primitiveType:tt.TRIANGLES,boundingSphere:new I.fromVertices(f)})};var X=k;function ht(t,e){return r(e)&&(t=X.unpack(t,e)),t._ellipsoid=l.clone(t._ellipsoid),X.createGeometry(t)}var Ot=ht;export{Ot as default};